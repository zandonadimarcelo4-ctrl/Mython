// Gramática EBNF para Mython - 99% Python Coverage
// Baseada em inglês A2/B1 - Linguagem Natural
// Usa indentação estilo Python com INDENT/DEDENT

%declare INDENT DEDENT _NEWLINE

?start: statement+

?statement: simple_stmt
         | compound_stmt

// Statements simples (não abrem blocos) - terminam com _NEWLINE
// ULTRA SIMPLES: apenas o essencial
simple_stmt: say_stmt _NEWLINE
           | ask_stmt _NEWLINE
           | assign_stmt _NEWLINE
           | augmented_assignment_stmt _NEWLINE
           | return_stmt _NEWLINE
           | break_stmt _NEWLINE
           | continue_stmt _NEWLINE
           | pass_stmt _NEWLINE
           | yield_stmt _NEWLINE
           | await_stmt _NEWLINE
           | raise_stmt _NEWLINE
           | assert_stmt _NEWLINE
           | wait_stmt _NEWLINE
           | random_stmt _NEWLINE
           | use_stmt _NEWLINE
           | from_import_stmt _NEWLINE
           | list_stmt _NEWLINE
           | dict_stmt _NEWLINE
           | tuple_stmt _NEWLINE
           | set_stmt _NEWLINE
           | add_to_list_stmt _NEWLINE
           | remove_from_list_stmt _NEWLINE
           | slice_stmt _NEWLINE
           | walrus_stmt _NEWLINE
           | type_hint_stmt _NEWLINE
           | lambda_stmt _NEWLINE
           | save_file_stmt _NEWLINE
           | read_file_stmt _NEWLINE
           | python_escape _NEWLINE

// Statements compostos (abrem blocos indentados) - não terminam com _NEWLINE
// IMPORTANTE: Ordem importa - mais específicos primeiro para evitar ambiguidades
// init_stmt e task_stmt só existem DENTRO de classes, não no nível superior
compound_stmt: async_function_def
             | function_def
             | class_def
             | if_stmt
             | elif_stmt
             | else_stmt
             | while_stmt
             | for_each_stmt
             | repeat_stmt
             | attempt_stmt
             | catch_stmt
             | finally_stmt
             | match_stmt
             | case_stmt
             | with_stmt
             | open_file_stmt

// Saída (ULTRA SIMPLES: apenas "say")
say_stmt: "say" expr

// Entrada (ULTRA SIMPLES: apenas "ask" + opcional "number")
// ask name = input() ou ask name number = int(input())
ask_stmt: "ask" NAME "number" STRING?
        | "ask" NAME "number"
        | "ask" NAME STRING?
        | "ask" NAME

// Condições (ULTRA SIMPLES: apenas "if" e "else")
if_stmt: "if" condition ":" _NEWLINE INDENT statement+ DEDENT
elif_stmt: "else" "if" condition ":" _NEWLINE INDENT statement+ DEDENT
else_stmt: "else" ":" _NEWLINE INDENT statement+ DEDENT

// Loops (ULTRA SIMPLES: apenas "for", "while", "repeat")
while_stmt: "while" condition ":" _NEWLINE INDENT statement+ DEDENT
for_each_stmt: "for" NAME "in" expr ":" _NEWLINE INDENT statement+ DEDENT
repeat_stmt: "repeat" NUMBER ":" _NEWLINE INDENT statement+ DEDENT

// Funções (ULTRA SIMPLES: apenas "def")
async_function_def: "async" "def" NAME "(" params? ")" ":" _NEWLINE INDENT statement+ DEDENT
function_def: "def" NAME "(" params? ")" ":" _NEWLINE INDENT statement+ DEDENT
return_stmt: "return" expr?

// Classes - Usando INDENT/DEDENT para blocos
// init_stmt e task_stmt são statements válidos APENAS dentro de class_def
// Eles são tratados como statements normais quando dentro da classe
class_def: ("class" | "create" "class" | "make" "class" | "define" "class") NAME ("(" inheritance ")")? ":" _NEWLINE INDENT statement+ DEDENT
// init_stmt: método especial __init__ (só dentro de classes)
// task_stmt: métodos de classe (só dentro de classes)
// Ambos usam a mesma estrutura de function_def, mas o transformer diferencia pelo contexto

// Exceções (ULTRA SIMPLES: apenas "try", "except", "finally")
attempt_stmt: "try" ":" _NEWLINE INDENT statement+ DEDENT
catch_stmt: "except" (NAME ("as" NAME)?)? ":" _NEWLINE INDENT statement+ DEDENT
finally_stmt: "finally" ":" _NEWLINE INDENT statement+ DEDENT

// Match/Case - Usando INDENT/DEDENT para blocos
match_stmt: "match" expr ":" _NEWLINE INDENT case_stmt+ DEDENT
case_stmt: "case" pattern ":" _NEWLINE INDENT statement+ DEDENT

// With statement - Usando INDENT/DEDENT para blocos
with_stmt: "with" expr ("as" NAME)? ":" _NEWLINE INDENT statement+ DEDENT

// Atribuições (ULTRA SIMPLES: sem palavra-chave, apenas =)
assign_stmt: NAME "=" expr
augmented_assignment_stmt: NAME ("+=" | "-=" | "*=" | "/=" | "//=" | "%=" | "**=") expr

// Controle de fluxo (ULTRA SIMPLES: apenas palavras Python)
break_stmt: "break"
continue_stmt: "continue"
pass_stmt: "pass"

// Estruturas de dados
list_stmt: ("list" | "create" "list" | "make" "list") NAME "=" list_literal
dict_stmt: ("dict" | "dictionary" | "create" "dict" | "make" "dict") NAME "=" dict_literal
tuple_stmt: ("tuple" | "create" "tuple" | "make" "tuple") NAME "=" tuple_literal
set_stmt: ("set" | "create" "set" | "make" "set") NAME "=" set_literal

// Operações de lista
add_to_list_stmt: ("add" | "append" | "put" | "insert") expr ("to" | "into") NAME
remove_from_list_stmt: ("remove" | "delete" | "take" "out") expr "from" NAME

// Utilitários
wait_stmt: ("wait" | "pause" | "sleep" | "delay") NUMBER ("seconds" | "second")
random_stmt: ("random" "number" "from" | "random" "between" | "pick" "random" "number" "from" | "get" "random" "number" "from" | "choose" "random" "number" "from" | "select" "random" "number" "from") expr ("to" | "and") expr

// Arquivos
save_file_stmt: ("save" "text" | "write" | "save" | "store") expr ("to" "file" | "into" "file" | "in" "file") STRING
read_file_stmt: ("read" "file" | "load" "file" | "get" "from" "file") STRING "as" NAME
open_file_stmt: ("open" | "open" "file" | "read" "file" | "load" "file") STRING "as" NAME ":" _NEWLINE INDENT statement+ DEDENT

// Imports
use_stmt: ("use" | "import" | "load" | "require" | "include") NAME ("as" NAME)?
from_import_stmt: "from" NAME ("import" | "load" | "require") NAME ("as" NAME)?

// Avançado
lambda_stmt: NAME "=>" expr
           | NAME "->" expr
yield_stmt: ("yield" | "produce" | "generate" | "return" "and" "continue") expr
await_stmt: "await" expr
raise_stmt: ("raise" | "throw" | "raise" "error" | "throw" "error") expr
assert_stmt: ("assert" | "check" | "verify" | "ensure") expr ("," expr)?

// Slicing simplificado
slice_stmt: "slice" NAME "from" expr "to" expr

// Walrus operator
walrus_stmt: NAME ":=" expr

// Type hints
type_hint_stmt: NAME ":" type_annotation ("=" expr)?
type_annotation: NAME | "int" | "str" | "float" | "bool" | "list" | "dict" | "tuple" | "set" | "None"

// Expressões
condition: expr comparison expr
         | expr ("is" | "equals" | "equal" "to") expr
         | expr ("is" "not" | "not" "equal" "to") expr
         | expr ("is" "over" | "is" "greater" "than" | "is" "above" | "greater" "than") expr
         | expr ("is" "under" | "is" "less" "than" | "is" "below" | "less" "than") expr
         | expr ("is" "at" "least" | "is" "greater" "than" "or" "equal" "to") expr
         | expr ("is" "at" "most" | "is" "less" "than" "or" "equal" "to") expr
         | expr ("is" "in" | "is" "not" "in") expr

comparison: ">" | "<" | ">=" | "<=" | "==" | "!="

// Expressões RESTRITAS (não competem com statements)
?expr: term (("+" | "-") term)*
?term: factor (("*" | "/" | "//" | "%" | "**") factor)*
?factor: NUMBER | STRING | NAME | "(" expr ")" | function_call | attribute_access | subscription | list_comprehension | dict_comprehension | set_comprehension

function_call: NAME "(" args? ")"
args: expr ("," expr)*
     | args_varargs ("," expr)*
     | expr ("," args_varargs)?
     | args_varargs ("," kwargs_varargs)?
     | kwargs_varargs

args_varargs: "*" NAME
kwargs_varargs: "**" NAME

attribute_access: NAME "." NAME
subscription: NAME "[" expr "]"

list_comprehension: "list" "[" expr "for" NAME "in" expr ("if" condition)? "]"
dict_comprehension: "dict" "{" expr ":" expr "for" NAME "in" expr ("if" condition)? "}"
set_comprehension: "set" "{" expr "for" NAME "in" expr ("if" condition)? "}"

list_literal: "[" (expr ("," expr)*)? "]"
dict_literal: "{" (expr ":" expr ("," expr ":" expr)*)? "}"
tuple_literal: "(" (expr ("," expr)*)? ")"
set_literal: "{" (expr ("," expr)*)? "}"

// prompt removido - usando STRING | expr diretamente em ask_stmt
inheritance: NAME ("," NAME)*
params: NAME ("," NAME)*
pattern: expr | "_" | tuple_pattern | list_pattern
tuple_pattern: "(" pattern ("," pattern)* ")"
list_pattern: "[" pattern ("," pattern)* "]"

// Python puro (escape) - MUITO RESTRITIVO
// Só captura linhas que NÃO começam com keywords Mython
python_escape: /(?!^\s*(if|elif|else|when|whenever|say|print|show|display|tell|ask|get|read|prompt|for|while|def|class|try|except|finally|with|repeat|do|loop|break|stop|continue|skip|pass|set|assign|let|make|put|store|save|create|initialize|define|function|return|give|back|send|add|append|remove|delete|wait|random|use|from|import|attempt|catch|raise|assert|lambda|yield|await|match|case|list|dict|tuple|set)\b).+/

// Terminais
NAME: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /\d+(\.\d+)?/
STRING: /"[^"]*"|'[^']*'|f"[^"]*"|f'[^']*'|r"[^"]*"|r'[^']*'|b"[^"]*"|b'[^']*'/

%import common.WS
// NÃO ignoramos WS - precisamos para indentação
// O indenter vai processar NEWLINE, INDENT e DEDENT
// _NEWLINE é declarado via %declare, não definido como terminal aqui
