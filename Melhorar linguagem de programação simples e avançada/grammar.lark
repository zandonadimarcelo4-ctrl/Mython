// Gramática EBNF para Mython - 99% Python Coverage
// Baseada em inglês A2/B1 - Linguagem Natural
// Usa indentação estilo Python com INDENT/DEDENT

%declare INDENT DEDENT

?start: statement+

// IMPORTANTE: _NEWLINE deve estar no nível de statement, NÃO no nível de simple_stmt
// Isso permite que blocos INDENT/DEDENT funcionem corretamente com o indenter
// O indenter injeta DEDENT seguido de _NEWLINE, e a gramática precisa aceitar isso
?statement: simple_stmt _NEWLINE
         | compound_stmt

// Statements dentro de blocos INDENT/DEDENT - _NEWLINE é opcional
// IMPORTANTE: Esta regra é usada dentro de blocos (if, while, for, etc.)
// O último statement pode ser seguido diretamente por DEDENT, sem _NEWLINE
// Por isso statements dentro de blocos têm _NEWLINE opcional
?block_stmt: simple_stmt _NEWLINE?
           | compound_stmt

// Statements simples (não abrem blocos) - NÃO terminam com _NEWLINE aqui
// ULTRA SIMPLES: apenas o essencial
// ULTRA SIMPLES: apenas o essencial
// IMPORTANTE: Ordem importa - mais específicos primeiro (say antes de python_escape)
// IMPORTANTE: _NEWLINE foi movido para o nível de statement para permitir blocos INDENT/DEDENT
simple_stmt: call_stmt
           | say_stmt

           | ask_stmt
           | assign_stmt
           | augmented_assignment_stmt
           | return_stmt
           | break_stmt
           | continue_stmt
           | pass_stmt
           | yield_stmt
           | await_stmt
           | raise_stmt
           | assert_stmt
           | wait_stmt
           | random_stmt
           | from_import_stmt
           | list_stmt
           | dict_stmt
           | tuple_stmt

           | add_to_list_stmt
           | remove_from_list_stmt
           | slice_stmt
           | walrus_stmt
           | type_hint_stmt
           | lambda_stmt
           | save_file_stmt
           | read_file_stmt
           | use_library_stmt // Novo: usar biblioteca
           // python_escape  // TEMPORARIAMENTE DESABILITADO PARA DEBUG

// Statements compostos (abrem blocos indentados) - não terminam com _NEWLINE
// IMPORTANTE: Ordem importa - mais específicos primeiro para evitar ambiguidades
// init_stmt e task_stmt só existem DENTRO de classes, não no nível superior
compound_stmt: async_function_def
             | function_def
             | class_def
             | if_stmt
             | while_stmt
             | for_each_stmt
             | repeat_stmt
             | attempt_stmt
             | catch_stmt
             | finally_stmt             | match_stmt
             | with_stmt            | open_file_stmt

// Saída (ULTRA SIMPLES: apenas "say")
say_stmt: SAY expr

// Entrada (ULTRA SIMPLES: apenas "ask" + opcional "number")
// ask name = input() ou ask number name = int(input())
// SOLUÇÃO: Usar ask_type como regra separada para garantir parsing correto
// CORRIGIDO: Usar ASK terminal em vez de "ask" literal
ask_stmt: ASK ask_type NAME STRING?
        | ASK ask_type NAME
        | ASK NAME STRING?
        | ASK NAME

// Tipo de entrada (number ou text)
// IMPORTANTE: Usar NUMBER_TYPE e TEXT_TYPE em vez de literais para garantir precedência
ask_type: NUMBER_TYPE -> number
        | TEXT_TYPE -> text

// Condições (ULTRA SIMPLES: apenas "if" e "else")
// IMPORTANTE: else_block NÃO é um statement separado - é parte do if_stmt
// O else vem DEPOIS do DEDENT do bloco if, mas ainda dentro da regra if_stmt
// O indenter SEMPRE injeta _NEWLINE após DEDENT, então o else_block precisa aceitar _NEWLINE* antes do "else"
// IMPORTANTE: Dentro de blocos INDENT/DEDENT, usar block_stmt em vez de statement
// CORRIGIDO: Usar IF e ELSE terminais em vez de literais
if_stmt: IF condition ":" _NEWLINE INDENT block_stmt+ DEDENT else_block?
elif_stmt: ELSE IF condition ":" _NEWLINE INDENT block_stmt+ DEDENT else_block?
else_block: _NEWLINE* ELSE ":" _NEWLINE INDENT block_stmt+ DEDENT

// Loops (ULTRA SIMPLES: apenas "for", "while", "repeat")
// IMPORTANTE: Dentro de blocos INDENT/DEDENT, usar block_stmt em vez de statement
// CORRIGIDO: Usar WHILE terminal em vez de "while" literal
while_stmt: WHILE condition ":" _NEWLINE INDENT block_stmt+ DEDENT
for_each_stmt: FOR NAME IN expr ":" _NEWLINE INDENT block_stmt+ DEDENT
repeat_stmt: REPEAT NUMBER ":" _NEWLINE INDENT block_stmt+ DEDENT

// Funções (ULTRA SIMPLES: "def" ou "func")
// IMPORTANTE: Dentro de blocos INDENT/DEDENT, usar block_stmt em vez de statement
// CORRIGIDO: Usar DEF/FUNC terminais em vez de literais
async_function_def: "async" DEF NAME "(" params? ")" ":" _NEWLINE INDENT block_stmt+ DEDENT
function_def: (DEF | FUNC) NAME "(" params? ")" ":" _NEWLINE INDENT block_stmt+ DEDENT
return_stmt: RETURN expr?

// Classes - Usando INDENT/DEDENT para blocos
// init_stmt e task_stmt são statements válidos APENAS dentro de class_def
// Eles são tratados como statements normais quando dentro da classe
// IMPORTANTE: Dentro de blocos INDENT/DEDENT, usar block_stmt em vez de statement
class_def: ("class" | "create" "class" | "make" "class" | "define" "class") NAME ("(" inheritance ")")? ":" _NEWLINE INDENT block_stmt+ DEDENT
// init_stmt: método especial __init__ (só dentro de classes)
// task_stmt: métodos de classe (só dentro de classes)
// Ambos usam a mesma estrutura de function_def, mas o transformer diferencia pelo contexto

// Exceções (ULTRA SIMPLES: apenas "try", "except", "finally")
// IMPORTANTE: Dentro de blocos INDENT/DEDENT, usar block_stmt em vez de statement
attempt_stmt: "try" ":" _NEWLINE INDENT block_stmt+ DEDENT
catch_stmt: "except" (NAME ("as" NAME)?)? ":" _NEWLINE INDENT block_stmt+ DEDENT
finally_stmt: "finally" ":" _NEWLINE INDENT block_stmt+ DEDENT

// Match/Case - Usando INDENT/DEDENT para blocos
match_stmt: "match" expr ":" _NEWLINE INDENT case_stmt+ DEDENT
case_stmt: "case" pattern ":" _NEWLINE INDENT statement+ DEDENT

// With statement - Usando INDENT/DEDENT para blocos
with_stmt: "with" expr ("as" NAME)? ":" _NEWLINE INDENT statement+ DEDENT

// Atribuições (ULTRA SIMPLES: sem palavra-chave, apenas =)
assign_stmt: NAME "=" expr
augmented_assignment_stmt: NAME ("+=" | "-=" | "*=" | "/=" | "//=" | "%=" | "**=") expr

// Controle de fluxo (ULTRA SIMPLES: apenas palavras Python)
break_stmt: "break"
continue_stmt: "continue"
pass_stmt: "pass"

// Estruturas de dados
list_stmt: ("list" | "create" "list" | "make" "list") NAME "=" list_literal
dict_stmt: ("dict" | "dictionary" | "create" "dict" | "make" "dict") NAME "=" dict_literal
tuple_stmt: ("tuple" | "create" "tuple" | "make" "tuple") NAME "=" tuple_literal
set_stmt: ("set" | "create" "set" | "make" "set") NAME "=" set_literal

// Operações de lista
add_to_list_stmt: ("add" | "append" | "put" | "insert") expr ("to" | "into") NAME
remove_from_list_stmt: ("remove" | "delete" | "take" "out") expr "from" NAME

// Utilitários
wait_stmt: ("wait" | "pause" | "sleep" | "delay") NUMBER ("seconds" | "second")
random_stmt: ("random" "number" "from" | "random" "between" | "pick" "random" "number" "from" | "get" "random" "number" "from" | "choose" "random" "number" "from" | "select" "random" "number" "from") expr ("to" | "and") expr

// Arquivos
save_file_stmt: ("save" "text" | "write" | "save" | "store") expr ("to" "file" | "into" "file" | "in" "file") STRING
read_file_stmt: ("read" "file" | "load" "file" | "get" "from" "file") STRING "as" NAME
open_file_stmt: ("open" | "open" "file" | "read" "file" | "load" "file") STRING "as" NAME ":" _NEWLINE INDENT statement+ DEDENT

// Novo: Chamada de função simples (sem atribuição)
call_stmt: function_call

// Novo: Importação simplificada de biblioteca
use_library_stmt: ("use" | "import" | "load" | "require" | "include") NAME ("as" NAME)?
                | ("use" | "import" | "load" | "require" | "include") "library" NAME ("as" NAME)?

// Imports
from_import_stmt: "from" NAME ("import" | "load" | "require") NAME ("as" NAME)?

// Avançado
lambda_stmt: NAME "=>" expr
           | NAME "->" expr
yield_stmt: ("yield" | "produce" | "generate" | "return" "and" "continue") expr
await_stmt: "await" expr
raise_stmt: ("raise" | "throw" | "raise" "error" | "throw" "error") expr
assert_stmt: ("assert" | "check" | "verify" | "ensure") expr ("," expr)?

// Slicing simplificado
slice_stmt: "slice" NAME "from" expr "to" expr

// Walrus operator
walrus_stmt: NAME ":=" expr

// Type hints
type_hint_stmt: NAME ":" type_annotation ("=" expr)?
type_annotation: NAME | "int" | "str" | "float" | "bool" | "list" | "dict" | "tuple" | "set" | "None"

// Expressões - ULTRA SIMPLIFICADAS para evitar ambiguidade
// IMPORTANTE: Restringir ao mínimo para garantir que o parser saiba quando a expressão termina
?condition: comparison
          | atom

// Comparação simples: NAME comparison_op atom
comparison: atom comparison_op atom

// Átomo (valor simples)
?atom: NAME | NUMBER | STRING
     | "(" expr ")"  -> paren_expr
     | function_call
     | attribute_access
     | subscription

// Operadores de comparação Python (suportados após normalize_operators)
// IMPORTANTE: Definir como terminais para evitar conflitos
GREATER: ">"
LESS: "<"
GREATER_EQUAL: ">="
LESS_EQUAL: "<="
EQUALS: "=="
NOT_EQUAL: "!="

// Operador de comparação
comparison_op: GREATER | LESS | GREATER_EQUAL | LESS_EQUAL | EQUALS | NOT_EQUAL

// Expressões - Expandidas com operadores aritméticos
// Prioridade: adição/subtração mais baixa, depois multiplicação/divisão, depois átomos
?expr: sum
?sum: product
    | sum "+" product  -> add
    | sum "-" product  -> sub
?product: atom
        | product "*" atom  -> mul
        | product "/" atom  -> div
        | product "//" atom -> floordiv
        | product "%" atom  -> mod
        | product "**" atom -> pow

// Átomo (valor simples) - já definido acima em condition
// ?atom: NAME | NUMBER | STRING  // Removido - já definido acima

function_call: NAME "(" args? ")"

// Argumentos de função
args: expr ("," expr)*
     | args_varargs ("," expr)*
     | expr ("," args_varargs)?
     | args_varargs ("," kwargs_varargs)?
     | kwargs_varargs

args_varargs: "*" NAME
kwargs_varargs: "**" NAME

attribute_access: NAME "." NAME
subscription: NAME "[" expr "]"

list_comprehension: "list" "[" expr "for" NAME "in" expr ("if" condition)? "]"
dict_comprehension: "dict" "{" expr ":" expr "for" NAME "in" expr ("if" condition)? "}"
set_comprehension: "set" "{" expr "for" NAME "in" expr ("if" condition)? "}"

list_literal: "[" (expr ("," expr)*)? "]"
dict_literal: "{" (expr ":" expr ("," expr ":" expr)*)? "}"
tuple_literal: "(" (expr ("," expr)*)? ")"
set_literal: "{" (expr ("," expr)*)? "}"

// prompt removido - usando STRING | expr diretamente em ask_stmt
inheritance: NAME ("," NAME)*
params: NAME ("," NAME)*
pattern: expr | "_" | tuple_pattern | list_pattern
tuple_pattern: "(" pattern ("," pattern)* ")"
list_pattern: "[" pattern ("," pattern)* "]"

// Python puro (escape) - TEMPORARIAMENTE DESABILITADO PARA DEBUG DO INDENTER
// TODO: Reativar após corrigir problemas de indentação
// python_escape: /(?!\s*(if|elif|else|when|whenever|say|print|show|display|tell|ask|get|read|prompt|for|while|def|class|try|except|finally|with|repeat|do|loop|break|stop|continue|skip|pass|set|assign|let|make|put|store|save|create|initialize|define|function|return|give|back|send|add|append|remove|delete|wait|random|use|from|import|attempt|catch|raise|assert|lambda|yield|await|match|case|list|dict|tuple|set)\b)(?!["']).+/

// Terminais
// IMPORTANTE: Ordem importa MUITO no Lark - palavras-chave específicas PRIMEIRO, NAME por último
// STRING deve estar antes de python_escape para ser capturado corretamente
STRING: /"[^"]*"|'[^']*'/
FSTRING: /f"[^"]*"|f'[^']*'/
RSTRING: /r"[^"]*"|r'[^']*'/
BSTRING: /b"[^"]*"|b'[^']*'/

// IMPORTANTE: Tipos e palavras-chave PRIMEIRO (antes de NAME)
// Isso garante que "number", "text", "ask", "say", "if", "else" sejam tokenizados corretamente
// e não virem NAME genérico
NUMBER_TYPE: "number"
TEXT_TYPE: "text"
ASK: "ask"
SAY: "say"
IF: "if"
ELSE: "else"
WHILE: "while"
FOR: "for"
IN: "in"
DEF: "def"
FUNC: "func"
CLASS: "class"
RETURN: "return"
BREAK: "break"
CONTINUE: "continue"
PASS: "pass"
REPEAT: "repeat"
UNTIL: "until"

// NAME por último (captura o que sobrou - variáveis, funções, etc.)
NAME: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /\d+(\.\d+)?/

// Definir _NEWLINE explicitamente para o indenter
COMMENT: /#[^\n]*/
%ignore COMMENT
// IMPORTANTE: Captura newline + espaços/tabs seguintes (indentação)
_NEWLINE: /(\r?\n[ \t]*)+/

// Ignorar apenas espaços/tabs entre tokens (NÃO newlines - eles são capturados por _NEWLINE)
%ignore /[ \t]+/
